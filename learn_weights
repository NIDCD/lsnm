#!/usr/bin/env python3

import argparse
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
from torch.utils.data import DataLoader
from tqdm import tqdm

# Define the neural network
class SimpleNetwork(nn.Module):
    def __init__(self):
        super(SimpleNetwork, self).__init__()
        self.fc = nn.Sequential(
            nn.Linear(784, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU(),
            nn.Linear(128, 10)  # Output: 10 classes for digits 0â€“9
        )

    def forward(self, x):
        return self.fc(x)

# Training function
def train(model, dataloader, criterion, optimizer, device):
    model.train()
    for images, labels in tqdm(dataloader, desc="Training"):
        images = images.view(images.size(0), -1).to(device)  # Flatten images
        labels = labels.to(device)

        optimizer.zero_grad()
        outputs = model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

# Main function
def main(args):
    # Set up device
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    # Load dataset
    transform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5,), (0.5,))])
    dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform)
    dataloader = DataLoader(dataset, batch_size=32, shuffle=True)

    # Initialize model, loss, and optimizer
    model = SimpleNetwork().to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    # Train the model
    train(model, dataloader, criterion, optimizer, device)

    # Save the trained weights
    torch.save(model.state_dict(), args.output)
    print(f"Trained weights saved to {args.output}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description=(
            "Train a neural network to generate weights for the LSNM model. "
            "The script uses the MNIST dataset by default and saves the trained weights "
            "in a PyTorch state dictionary format."
        )
    )
    parser.add_argument(
        "--output",
        type=str,
        required=True,
        help=(
            "Path to save the trained weights. The output will be a PyTorch state dictionary "
            "file (e.g., .pth or .pt) containing the model's parameters."
        ),
    )
    args = parser.parse_args()

    main(args)